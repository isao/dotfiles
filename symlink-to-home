#!/bin/bash -eu
set -eu -o pipefail

# For every file in this repo, except the ones matched in `$ignore_file`:
# - create a symlink in $HOME for the source dotfile pathname, including any
#   intermediate directories.
# - add a "." to the symlinked pathname (so they're not hidden in this repo).
#
# Example:
#   ./home/zshrc          -> $HOME/.zshrc
#   ./home/config/foo/bar -> $HOME/.config/foo/bar

repo_abspath="$(cd "$(dirname "$0")" && git rev-parse --show-toplevel)"

ignore_file="$repo_abspath/exclude.ini"

backup_dir="${TMPDIR:-/tmp}/dotfiles-$(date +%Y%m%d-%H%M%S)"

# Pass `--dry-run` to echo commands instead of running them.
[[ "${1:-}" == "--dry-run" ]] && run="echo" || run=

# Change the working directory for `fd` to output the relative path.
cd "$repo_abspath"

echo "* Symlinking dotfiles."
while read -r source_pathname
do
    # Prefix the symlink pathname that we're going to make with a dot.
    link_pathname=".${source_pathname}"

    # Make parent sub-directories, if the source file is in a subdirectory.
    link_dirname="$(dirname "$link_pathname")"
    [[ "$link_dirname" != '.' ]] && \
        $run mkdir -p "$HOME/$link_dirname"

    # Move pre-existing files to a backup directory.
    [[ -e "$HOME/$link_pathname" || -L "$HOME/$link_pathname" ]] && {
        $run mkdir -p "$backup_dir/$link_dirname"
        $run mv "$HOME/$link_pathname" "$backup_dir/$link_pathname"
    }

    # Symlink source dotfile to $HOME.
    $run ln -sv "$repo_abspath/$source_pathname" "$HOME/$link_pathname"

done < <(command fd --type f --ignore-file="$ignore_file")

# Clean up backup directory if empty, otherwise report location.
[[ -d "$backup_dir" ]] && {
    rmdir "$backup_dir" 2>/dev/null || echo "Backups saved to: $backup_dir"
}

# Fix permissions. `git` operations will apply the default `umask`, but these
# should be more restrictive. `chmod` follows symlinks.
echo "* Setting permissions."
$run chmod -vv 700 "$HOME/.ssh"
$run chmod -vv 600 "$HOME/.ssh/config" "$HOME/.ssh/config-"* 2>/dev/null || true

echo "* Done."
